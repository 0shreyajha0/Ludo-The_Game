includes/board.hpp
---------------------------------------------------
    FUTURE and TODOS
    ================
    //  FUTURE+ERRORS  //
    //[FUTURE] - Consider the chances of using std::list or std::set in places where std::vector has been used...
    //[FUN][FUTURE] - if(number of that colour gotis = 0 earlier), then
    //Congratulate THE USER "Chal yaar, ek ludo_goti to nikli ;-)"

    //[ERROR]: [at declaration of 'coord_class::stops'] Accessing these gives error: this declaration has no storage class or type specifier

    COMMENTS
    =========
    //[DONE]TODO - Organize into private and public
    //[DONE](using smart pointers) iterator through whole board, and 'delete ludo_goti initialised with unlockGoti()'
    //[SOLVED]Bug - When non-static, these show mulitple 'definitions'
    /*[LEARNT] random_device is slower than mt19937, but doesnt matter much, since its used to seed only once
    the Mersenn(-_-) twister is about 10x faster than default C random generator*/
    //[DONE]TODO - Append gotis to these locked Positions, using shared_ptr<ludo_goti>
    //QUESTION - How to create an 'array' of reference_wrappers?? [ANSWER]Can't create one, since reference_wrapper can't be default initialised
    //[LEARNT] We use random_device to seed the 'random generator' named 'mt'
    /*[DONE]TODO - Lock the weak_ptr before passing the first argument of either attack or moveGoti*/

includes/board.cpp
---------------------------------------------------
    FUTURE and TODOS
    ================
	//TODO - Remove cases of triple sixes
	//TODO - Modify code such that instead of checking if enteredRoll is in dieNumbers, check whether it's a sum of elements or not

    COMMENTS
    =========
    /*TODO - 
		[DONE]Checking if move possible or not
		[DONE]Checking at each loop, whether it is at stop, to update gotiStatus
		[DONE]Checking at each loop, whether the coord is in home_turn, (to make algorithm better, check if dist remaining <= 6, if not return false straightaway)
	*/
    /*[LEARNT] - Nesting functions (ie. function declaration inside function) is not supported by standards in C/C++
                    But, gcc supports it as a 'non-standard' extension
                    BUT, in C++ mode, it's not allowed, 'Local Functions' aren't supported
                    BUT, FROM C++11, IT IS SUPPORTED, using LAMDAs {Imp. - Lambdas have a semicolon at end}*/
    /*LAMBDAs - 1. Have a ';' at end
                2. '[]' is the "capture clause", also called 'lambda-introducer'
                3. parameter list '()' is optional
                4. These are the parts:
                        [] () mutable throw() -> int {//body//}
                        |  |   |        |       |    
            capture clause  |  optional  |  trailing-return-type(optional)
                        parameters   exception specification(optional)
    */
    /*Question - Why didnt this lambda work? [Solved, that brings a smile ;D]
       }while ( (tmpDimen.getKey() < 31 || tmpDimen.getVal() < 31) ? true : []{	//Lamda Function (used to declare this 'local' function)
       	cerr<<"INSUFFICIENT HEIGHT/WIDTH FOR DISPLAY!"<<endl;
       	return false;
       } );*/

includes/enumerations.hpp
---------------------------------------------------
    COMMENTS
    =========
    /*[LEARNT] - Defining enum data type, they get values starting from 0, and having variables of this user defined type
    "enumerator value must have integral or unscoped enumeration type"
    3. Though they may have integer value, BUT we can't assign an integer to an enum variable, It shows this error - invalid conversion from ‘int’ to ‘colours’ [-fpermissive]
    4. These identifiers will be available in the same scope as the declaration, eg. here, it's global scope*/

includes/ludo_goti.hpp
---------------------------------------------------
    COMMENTS
    =========
    //[DONE]TODO - Create a balance b/w friends, and private public
    //[DONE][FUTURE] - Likely chose between having coordinates, or pointer to ludo_goti(consider the NULL checks)
    //[DONE][FUTURE] - Improve security of this function, else coordinates being private wont be useful... Solution used... made moveGoti a friend function

includes/ludo_goti.cpp
---------------------------------------------------
    COMMENTS
    =========
    //[LEARNT_KNOW_MORE] - 'abstract' isn't a keyword in C++
    //[LEARNT] - 	//public Getters maybe used to ensure that private mamber can't be modified from outside
    //ERROR_SOLVED - Showing error : expected identifier before numeric constant std::pair<int,int> coords(0,0);
                        /*LEARNT - We can't call the constructor of a datatype right at declaration, "in a class outside any method"
                                But, we can braces{} instead of () to initialize right at declaration, BUT... by passing a constructed object
                                    vector<int> v(5);	//Wrong
                                    vector<int> v{vector<int>(5)}; //Right
                                    
                                So, first declare then, call their constructors in constructor(See this class's constructor)*/
    //LEARNT - We can't define, 'implicitly-"declared" function/constructor', we have to explicitly declare the constructor in the header

includes/ludo_coords
---------------------------------------------------
    FUTURE and TODOS
    ================
    //FUTURE - Shift to std::unordered_map from std::map

    COMMENTS
    =========
    /*QUESTION - With 'static', the functions give 'umdefined references' linker errors
				And, without 'static', the data members showed MULTIPLE DECLARATIONS (WHY ??)*/

includes/simpleTuple
---------------------------------------------------
    COMMENTS
    =========
    /*[QUESTION_Answered] - This gives error without the 'this->'? Why?
                            Answer - It is because unqualified lookup doesn't work here because the base is a template.
                                      So, we need to use this-> to access inherited members in childs of template classes*/
    /*[LEARNT] - Direct access through objects of Base Class, to protected members of Base Class,
                                                              is only in methods of the Base class, not even in Child
                                                              For. eg, you take an object of parent type (not 'this' object), then can't access in Child*/
    //DOWNSIDE_C++, QUESTION - We can't have virtual templated member function
    //LEARNT - In a templated function, if return types in if and blocks is different, then It wont be able to know the type
    /*[LEARNT] - In C++, protected members can't be accessed directly
                             In Java, protected members 'can' be accessed directly, but in same package*/

    /*[SOLVED]BUG : 
      Operator '<' is ONLY to solve this - 
      In file included from /usr/include/c++/7/functional:49:0,
                 from includes/ludo_box.hpp:24,
                 from includes/board.hpp:9,
                 from includes/board.cpp:1:
/usr/include/c++/7/bits/stl_function.h: In instantiation of ‘constexpr bool std::less<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = homoTuple<int>]’:
/usr/include/c++/7/bits/stl_tree.h:2141:8:   required from ‘std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, const key_type&) [with _Key = homoTuple<int>; _Val = std::pair<const homoTuple<int>, direction>; _KeyOfValue = std::_Select1st<std::pair<const homoTuple<int>, direction> >; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type = homoTuple<int>]’
/usr/include/c++/7/bits/stl_tree.h:2201:33:   required from ‘std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique_(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, _Arg&&, _NodeGen&) [with _Arg = const std::pair<const homoTuple<int>, direction>&; _NodeGen = std::_Rb_tree<homoTuple<int>, std::pair<const homoTuple<int>, direction>, std::_Select1st<std::pair<const homoTuple<int>, direction> >, std::less<homoTuple<int> >, std::allocator<std::pair<const homoTuple<int>, direction> > >::_Alloc_node; _Key = homoTuple<int>; _Val = std::pair<const homoTuple<int>, direction>; _KeyOfValue = std::_Select1st<std::pair<const homoTuple<int>, direction> >; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const homoTuple<int>, direction> >]’
/usr/include/c++/7/bits/stl_tree.h:2452:21:   required from ‘void std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique(_II, _II) [with _InputIterator = const std::pair<const homoTuple<int>, direction>*; _Key = homoTuple<int>; _Val = std::pair<const homoTuple<int>, direction>; _KeyOfValue = std::_Select1st<std::pair<const homoTuple<int>, direction> >; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >]’
/usr/include/c++/7/bits/stl_map.h:886:4:   required from ‘void std::map<_Key, _Tp, _Compare, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = const std::pair<const homoTuple<int>, direction>*; _Key = homoTuple<int>; _Tp = direction; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >’
/usr/include/c++/7/bits/stl_map.h:823:15:   required from ‘void std::map<_Key, _Tp, _Compare, _Alloc>::insert(std::initializer_list<std::pair<const _Key, _Tp> >) [with _Key = homoTuple<int>; _Tp = direction; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >]’
includes/board.cpp:524:4:   required from here
/usr/include/c++/7/bits/stl_function.h:386:20: error: no match for ‘operator<’ (operand types are ‘const homoTuple<int>’ and ‘const homoTuple<int>’)
       { return __x < __y; }
    */

includes/ludo_box
---------------------------------------------------
    FUTURE and TODOS
    ================

    COMMENTS
    =========
    /*QUESTION - Is it OK to pass 'references' of weak_ptr, and not by value ?*/
    /*QUESTION - When to use weak_ptr<> and when to use shared_ptr<> ?*/
    /*[DONE][by forcing no invalid goti to be even created]FUTURE - Do have null check
        ALTERNATE NULL CHECK -> For checking if passed ludo_goti is valid, check it's colour and/or coords to be valid
    */

includes/utilities
---------------------------------------------------
    COMMENTS
    =========
    //ERROR - [in getTerminalDimen()] Replace std::pair<int,int> with simpleTuple<int,int> gives error : conversion from ‘simpleTuple<int, int>’ to non-scalar type ‘std::pair<int,int> {aka homoTuple<int>}’ requested
    /*LEARNT - ASCII value of integers 0-9 are actually 48-57*/
        /*Learnt - In case of only 1 argument passed to std::string::erase()...
                    1. If we provide an index number, ALL including and after it are erased
                    2. If we provide an iterator,    ONLY that position is removed*/

        //LEARNT - algorithm -> find_if - Keep finding, until the predicate is true
        //LEARNT - Using .base() on a reverse_iterator returns us the normal_iterator, BUT CAUTION- This isn't advisable, and might cause SEGFAULT, (for eg. accessing .rbegin().base())

    /*LEARNT - stringify() can turn any name into text, BUT remember, it ignores trailing and front spaces, for eg. in stringify( Hello World ), first and last space ignored*(Verified)/
    */

    /*LEARNT - The component type of STL containers like vectors must be 'asignable'.
                References are NOT assignable, ie. we can only initialise them once, and,
                you can't make them reference something else later (you can't assign it to reference any other vairable, and even after equating 2 references, only the values of variable they reference is changed, not the addresses they both refer to)
                Due to same reason, other non-assignable types are also not allowed as components of containers, for eg. vector<const int> not allowed
    */

    //LEARNT+QUESTIONS BELOW [SIMPLETUPLE]//
     /*[QUESTION_Answered] - This gives error without the 'this->'? Why?
                                Answer - It is because unqualified lookup doesn't work here because the base is a template.
                                          So, we need to use this-> to access inherited members in childs of template classes*/
    /*[LEARNT] - Direct access through objects of Base Class, to protected members of Base Class,
                                                              is only in methods of the Base class, not even in Child
                                                              For. eg, you take an object of parent type (not 'this' object), then can't access in Child*/
      //DOWNSIDE_C++, QUESTION - We can't have virtual templated member function
      //LEARNT - In a templated function, if return types in if and blocks is different, then It wont be able to know the type
    /*[LEARNT] - In C++, protected members can't be accessed directly
                             In Java, protected members 'can' be accessed directly, but in same package*/
    /*NOTE, QUESTION - Did this to suppress this - In instantiation of ‘homoTuple<T>::homoTuple(T, T) [with T = int]’:
    ./util/terminalstd::pair<int,int>.hpp:17:24:   required from here
    ./util/./simpleTuple.hpp:70:30: error: no matching function for call to ‘simpleTuple<int, int>::simpleTuple()’
         homoTuple(T key, T value){ */


//LEARNT
. Cannot create a non-constant pointer to a member function
. To 'fully qualify' means to pass it as "&className::functionTryingToPass"